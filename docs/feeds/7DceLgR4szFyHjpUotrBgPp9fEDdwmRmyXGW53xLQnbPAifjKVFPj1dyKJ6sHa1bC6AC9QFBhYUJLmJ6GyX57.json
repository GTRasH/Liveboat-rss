{"id":"7DceLgR4szFyHjpUotrBgPp9fEDdwmRmyXGW53xLQnbPAifjKVFPj1dyKJ6sHa1bC6AC9QFBhYUJLmJ6GyX57","title":"top scoring links : linux","displayTitle":"Reddit - Linux","url":"https://www.reddit.com/r/linux/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/linux/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Resist Age checks now!","url":"https://www.reddit.com/r/linux/comments/1ri1eev/resist_age_checks_now/","date":1772381992,"author":"/u/ForeverHuman1354","guid":371,"unread":true,"content":"<p>Now that California is pushing for operating system-level age verification, I think it's time to consider banning countries or places that implement this. It started in the UK with age ID requirements for websites, and after that, other EU countries began doing the same. Now, US states are following suit, and with California pushing age verification at the operating system level, I think it's going to go global if companies accept it.</p><p>If we don't resist this, the whole world will be negatively impacted.</p><p>What methods should be done to resist this? Sadly, the most effective method I see is banning states and countries from using your operating system, maybe by updating the license of the OS to not allow users from those specific places.</p><p>If this is not resisted hard we are fucked</p>","contentLength":784,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Quickshare/Nearbyshare Implementation for linux based on the official nearby codebase from google","url":"https://www.reddit.com/r/linux/comments/1rhxo6q/quicksharenearbyshare_implementation_for_linux/","date":1772372787,"author":"/u/Striking-Storm-6092","guid":370,"unread":true,"content":"<p>Hi <a href=\"https://www.reddit.com/r/linux\">r/linux</a>. I got tired of waiting for google to support linux so I tried doing it myself. I submitted PRs for linux implementations on their official repo but the maintainers weren't that enthusiastic about a linux implementation.</p><p>RQuickShare the the likes exist but they use a reverse engineered version of the google nearby share protocol and so are WIFI-LAN only. I've built support for many of the official mediums they support.</p><table><thead><tr></tr></thead><tbody></tbody></table><p>If you're tired of finding creative ways to share files to your linux machines, feel free to check it out. Criticism is always appreciated :)</p><blockquote><p><strong>This is not just a quickshare/nearbyshare client. It is an implementation of the nearby connections/ nearby presence and fastpair protocol. So in theory other app developers can link against the library and build cool stuff</strong></p></blockquote><p>NOTE: The library/ client is still in  early beta. I can only guarantee that it works on my hardware for now. But in theory it should be universal since it uses dbus, networkmanager and bluez under the hood for most of the heavylifting.</p><p>NOTE 2: You'll need a companion app over <a href=\"https://github.com/kidfromjupiter/shareby\">here</a> for android to linux sharing. Don't worry, its almost as seamless as quickshare since it integrates into android's native share sheet. This app was mostly AI generated. The reasoning being that it is just a proof of concept. In the grand scheme of things, my main repo is very much a library with an app on the side. Instead of the other way around. </p>","contentLength":1428,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"GNU Hurd On Guix Is Ready With 64-bit Support, SMP Multi-Processor Support \"Soon\"","url":"https://www.phoronix.com/news/GNU-Hurd-64-bit-2026","date":1772372242,"author":"/u/anh0516","guid":372,"unread":true,"content":"\nAfter hearing last month that <a href=\"https://www.phoronix.com/news/GNU-Hurd-In-2026\">GNU Hurd is \"almost there\" with x86_64 support</a>, it was exciting to kickoff today by seeing a developer headline \"\" GNU Hurd 64-bit support is now said to be ready but SMP support for multiple processor cores and the like remain still in development.\n<p>The GNU Guix developer blog announced the headline today of 64-bit support. The GNU Guix distribution with Hurd rather than the Linux kernel is now available in an x86_64 flavor for those wanting to try it out. The post also outlines other progress made to GNU Hurd with the Guix distribution over the past year and a half.\n</p><p>There have been many fixes throughout for GNU Guix/Hurd, including to the installer. 64-bit Hurd is booting successfully and there is now an installer option for Hurd on x86_64.\n</p>While some may be excited over GNU Guix/Hurd, there is still a very limited subset of packages successfully building:\n<blockquote>\"In Guix only about 1.7% (32-bit) and 0.9% (64-bit) of packages are available for the Hurd. These percentages fluctuate a bit but continue to grow (both grew with a couple tenth percent point during the preparation of this blog post), and as always, might grow faster with your help.\n<p>So while Guix GNU/Hurd has an exciting future, please be aware that it lacks many packages and services, including Xorg.\"</p></blockquote>The <a href=\"https://guix.gnu.org/blog/2026/the-64-bit-hurd//\">GNU Guix blog post</a> concludes talking about Symmetric Multi-Processing (SMP) Support that \"<em>so most probably we'll have 64-bit multiprocessing real soon now! It seems however, that we will need new bootstrap binaries for that.</em>\"","contentLength":1535,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1rhxhcf/gnu_hurd_on_guix_is_ready_with_64bit_support_smp/"},{"title":"1994 Linux and CDE in a browser. Just found this.","url":"https://www.reddit.com/r/linux/comments/1rhq7kb/1994_linux_and_cde_in_a_browser_just_found_this/","date":1772347139,"author":"/u/Severe-Divide8720","guid":368,"unread":true,"content":"<p>I just came across an article about this and oh my.... Definitely a blast from the very far past. WARNING: May Make you feel very very old indeed. Cool to see where it all began though.</p>","contentLength":185,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I built a 1 GiB/s file encryption CLI using io_uring, O_DIRECT, and a lock-free triple buffer","url":"https://www.reddit.com/r/linux/comments/1rha5ng/i_built_a_1_gibs_file_encryption_cli_using_io/","date":1772303599,"author":"/u/supergari","guid":369,"unread":true,"content":"<p>I got frustrated with how slow standard encryption tools (like GPG or age) get when you throw a massive 50GB database backup or disk image at them. They are incredibly secure, but their core ciphers are largely single-threaded, usually topping out around 200-400 MiB/s.</p><p>I wanted to see if I could saturate a Gen4 NVMe drive while encrypting, so I built .</p><p>I started out just mapping files into memory, but to hit multi-gigabyte/s throughput without locking up the CPU or thrashing the kernel page cache, the architecture evolved into something pretty crazy:</p><ul><li><strong>Lock-Free Triple-Buffering:</strong> Instead of using async MPSC channels (which introduced severe lock contention on small chunks), I built a 3-stage rotating state machine. While io_uring writes batch N-2 to disk, Rayon encrypts batch N-1 across all 12 CPU cores, and io_uring reads batch N.</li><li> I wrote a custom 4096-byte aligned memory allocator using std::alloc. This pads the header and chunk slots so the Linux kernel can bypass the page cache entirely and DMA straight to the drive.</li><li> It uses ring for assembly-optimized AES-256-GCM and ChaCha20-Poly1305. To prevent chunk-reordering attacks, it uses a TLS 1.3-style nonce derivation (base_nonce XOR chunk_index).</li><li> The full serialized file header (which contains the Argon2id parameters, salt, and base nonce) plus an is_final flag are bound into every single chunk's AAD. This mathematically prevents truncation and append attacks.</li></ul><p>It reliably pushes  entirely CPU-bound, and scales beautifully with cores.</p><p>The README has a massive deep-dive into the binary file format, the memory alignment math, and the threat model. I'd love for the community to tear into the architecture or the code and tell me what I missed.</p><p>Let me know what you think!</p>","contentLength":1737,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Alliance of Open Media is working on Open Audio Codec, based on libopus & meant to succeed Opus","url":"https://github.com/AOMediaCodec/oac","date":1772299745,"author":"/u/TheTwelveYearOld","guid":373,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1rh8hn1/alliance_of_open_media_is_working_on_open_audio/"}],"tags":["dev"]}