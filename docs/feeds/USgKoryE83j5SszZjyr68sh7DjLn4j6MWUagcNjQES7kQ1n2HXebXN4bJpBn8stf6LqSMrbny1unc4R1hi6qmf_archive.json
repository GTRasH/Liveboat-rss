{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Revisiting interface segregation in Go","url":"https://www.reddit.com/r/golang/comments/1olzq5m/revisiting_interface_segregation_in_go/","date":1762032898,"author":"/u/sigmoia","guid":639,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/sigmoia\"> /u/sigmoia </a>","contentLength":30,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"to transaction or not to transaction","url":"https://www.reddit.com/r/golang/comments/1olxt4z/to_transaction_or_not_to_transaction/","date":1762028100,"author":"/u/PancakeWithSyrupTrap","guid":637,"unread":true,"content":"<p>Take this simplistic code:</p><p>func create(name string) error {</p><p>if err != nil { return err }</p><p>err := writeToDatabase(name)</p><p>if err != nil { return err}</p><p>func newDisk(name) error {</p><p>name, err := getDisk(name)</p><p>if err != nil { return err }</p><p>if name != \"\" { return nil }</p><p>if err != nil { return err}</p><p>This creates a disk and database record.</p><p>The `newDisk` function idempotently creates a disk. Why ? If writing a database record fails, there is an inconsistency. A real resource is created but there is no record of it. When client receives an error presumably it will retry, so a new disk will not be created and hopefully the database record is written. Now we are in a consistent state.</p><p>But is this a sensible approach ? In other words, shouldn't we guarantee we are always in a consistent state ? I'm thinking creating the disk and writing a database record should be atomic.</p>","contentLength":852,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Compile from a git repo but make changes","url":"https://www.reddit.com/r/golang/comments/1olx8jv/compile_from_a_git_repo_but_make_changes/","date":1762026706,"author":"/u/No-Confection8657","guid":636,"unread":true,"content":"<p>I am running a VPS with ubuntu aarch64 and have go 1.25. I am trying to compile a program from a repo that is written in go but want to also implement a change from a pull request. The repo isn't mine, though I do have a fork of it on my git. </p><p>I installed task and followed the steps in the <a href=\"http://contributing.md/\">contributing.md</a> file. When I \"task deps\" it did spit out an error that was basically the same as when I was doing it passing go commands manually:</p><p>I decided to just try ignoring that and running \"task\" to build it. And it seemed to compile and I have successfully ran it.</p><p>Here is my issue now - I manually made the changes to the VERSION and internal/tgc/channel_manager.go files locally before running this but I think it just went ahead and used the original versions ignoring my changes</p><p>when I run teldrive version it spits out 1.7.0 and the changes to the version file is 1.7.1 - also the file that got generated is the exact same amount of bytes as the 1.7.0 release. So I think it just made the file with none of the changes I had manually input into the local copies of the files.</p><p>Then when I run task, it exits with the following error:</p><p>task: Failed to run task \"default\": task: Command \"go run scripts/release.go --version current\" failed: exit status 1</p><p>not sure what would cause this - when I look at that file, it seems to just reference the VERSION file to get the version number. and it simply says 1.7.1 instead of 1.7.0</p><p>Am I missing something obvious? Sorry for the long post, I am new at this.</p>","contentLength":1492,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Convex Optimization (or Mathematical Programming) in Go","url":"https://www.reddit.com/r/golang/comments/1ols1gn/convex_optimization_or_mathematical_programming/","date":1762014224,"author":"/u/RobotCyclist23","guid":638,"unread":true,"content":"<p>Do you write a lot of Convex (or similar) Optimization problems and have been yearning for a way to model them in Go? <a href=\"https://github.com/MatProGo-dev/MatProInterface.go\">MatProInterface.go</a> can help you (and needs your input to gain more maturity)! Feel free to try it and let me know what you think!</p>","contentLength":247,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go's Context Logger","url":"https://github.com/pablovarg/contextlogger?tab=readme-ov-file#examples","date":1762007053,"author":"/u/PurityHeadHunter","guid":640,"unread":true,"content":"<p>Hello Gophers! A while ago, I started using contextual logging in my projects and found it made debugging significantly easier. Being able to trace request context through your entire call stack is a game-changer for understanding what's happening in your system.</p><p>This project started as a collection of utility functions I copy-pasted between projects. Eventually, it grew too large to maintain that way, so I decided to turn it into a proper library and share it with the community. <a href=\"https://github.com/PabloVarg/contextlogger\">https://github.com/PabloVarg/contextlogger</a></p><p>Context Logger is a library that makes it easy to propagate your logging context through Go's  and integrates seamlessly with Go's standard library, mainly  and . If this is something that you usually use or you're interested on using it for your projects, take a look at some <a href=\"https://github.com/pablovarg/contextlogger\">Usage Examples</a>.</p><p>For a very simple example, here you can see how to:</p><ul><li>Embed a logger into your context</li><li>Update the context (this can be done many times before logging)</li><li>Log everything that you have included in your context so far</li></ul><pre><code>ctx = contextlogger.EmbedLogger(ctx) contextlogger.UpdateContext(ctx, \"userID\", user.ID) contextlogger.LogWithContext(ctx, slog.LevelInfo, \"done\") </code></pre>","contentLength":1171,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1olp424/gos_context_logger/"},{"title":"Java Virtual Threads VS GO routines","url":"https://www.reddit.com/r/golang/comments/1oldyoo/java_virtual_threads_vs_go_routines/","date":1761967558,"author":"/u/gamecrow77","guid":635,"unread":true,"content":"<p>I recently had a argument with my tech lead about this , my push was for Go since its a new stack , new learning for the team and Go is evolving , my assumption is that we will find newer gen of devs who specialise in Go. Was i wrong here ? the argument was java with virtual threads is as efficient as go </p>","contentLength":306,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}