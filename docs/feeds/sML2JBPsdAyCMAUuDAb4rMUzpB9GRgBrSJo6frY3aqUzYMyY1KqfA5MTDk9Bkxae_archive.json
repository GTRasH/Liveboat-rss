{"id":"sML2JBPsdAyCMAUuDAb4rMUzpB9GRgBrSJo6frY3aqUzYMyY1KqfA5MTDk9Bkxae","title":"Blog - Bitfield Consulting","displayTitle":"Dev - Bitfield","url":"https://bitfieldconsulting.com/posts?format=rss","feedLink":"https://bitfieldconsulting.com/posts/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":4,"items":[{"title":"Go the right way: the Zen of Go coding","url":"https://bitfieldconsulting.com/posts/go-right-way","date":1771327440,"author":"John Arundel","guid":177,"unread":true,"content":"<figure><img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp\" data-image-dimensions=\"1280x720\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=1000w\" width=\"1280\" height=\"720\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/446b0ee7-8254-4dcf-a0d0-f66a3f2d4ae7/10x-commandments.webp?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\"><figcaption><p data-rte-preserve-empty=\"true\"><em>Illustration courtesy of JetBrains</em></p></figcaption></figure><p>Ever wondered if there’s a software engineer, somewhere, who actually\nknows what they’re doing? Well, I finally found the one serene,\nomnicompetent guru who writes perfect code. I can’t disclose the\nlocation of her mountain hermitage, but I  share her ten\nmantras of Go excellence. Let’s meditate on them together.</p><p> This is not medical advice. Side effects\nmay include higher code quality, reduced stress levels, and increased\nsalary.</p><h2>1. Write packages, not\nprograms</h2><p>What if I told you there was a library of over a million Go packages\nto do just about anything you could ever want? How much would it speed\nup your development if you could just import the package that solves\nyour problem, instead of painfully re-inventing it from scratch every\ntime?</p><p>Apparently we  have nice things, so it’s only fair that\nif you develop some useful Go code yourself, you should contribute it\nback to the universal library, right? That means writing your code not\nmerely as a one-off program for your own use case, but as a reliable,\nreusable, importable software component published with an open-source\nlicence.</p><p>Writing packages, not programs, has some design implications, too.\nKeep your  function minimal: its only job is to process\nflags and arguments, figure out what the user asked for, and call into\nyour “engine” package to do the actual work.</p><p>Your package shouldn’t print anything; instead, it should return the\ndata. Leave it up to the consumer of your package to decide what to do\nwith it. Similarly, don’t call  or\n in your package; return errors instead. Don’t\nrecover panics from your dependencies either: this can mask problems\nyour consumer needs to know about.</p><p>Keep your <a href=\"https://go.dev/doc/modules/layout\">module\nstructure</a> simple: ideally, a single package. Complex trees of\nsub-packages make it difficult for users to find what they need, and\nyou’ll give yourself import cycle headaches too. Instead, keep the\nstructure flat, and limit your package to just two files: one for the\nimplementation, and one for the tests.</p><p>Speaking of tests, my Go guru assures me that they’re the only true\npath to saintly software. When I mentor new Go programmers myself, I\nsometimes sense their hearts sinking a bit at the mention of tests.\nThere’s a perception that they’re like healthy exercise: undoubtedly a\ngood habit, but one that we all struggle to maintain. “Write tests” is\nlike “Go to the gym“, in other words: good advice, but hard to act\non.</p><p>On the contrary, I think it’s more like saying “Eat chocolate!”\nThat’s the kind of advice we all love to hear, and it doesn’t take much\nwillpower to apply.</p><p>Tests are great, and when you approach them the right way they can be\nfun to write. They’re a useful design tool, because writing a test makes\n the first user of your own function. If it’s awkwardly\nnamed, or has too many dependencies, or returns the wrong kind of\nresult, you’ll notice right away. If the thing you’re testing is easy to\nwrite a test for, it’ll be easy to use in real programs—and if it’s not,\nfix it so it is.</p><p>Writing tests helps you <a href=\"https://en.wikipedia.org/wiki/Eating_your_own_dog_food\">dogfood</a>\nyour packages: awkward names and inconvenient APIs are obvious when you\nuse them yourself.</p><p>Make your tests small and granular, focused on one small piece of\nlogic—maybe a single method or function—and use your package’s public\nAPI instead of sneaking behind the curtain to look at implementation\ndetails. Those might change, whereas the behaviours your users care\nabout shouldn’t. Check your test coverage to make sure you’ve tested all\nthe code that matters (and it all matters).</p><h2>3. Write code for reading</h2><p>The best way to make sure you’re writing readable code is to\n it. Put yourself in the mindset of someone who doesn’t\nalready know what the code does, and go through it line by line. Is it\neasy to follow what’s happening? Is the purpose clear? Are the names of\nfunctions and variables well-chosen to convey what they represent? How\nmuch <a href=\"https://medium.com/@egonelbre/psychology-of-code-readability-d23b1ff1258a\">cognitive\nload</a> are you asking them to lift?</p><p>Read other people’s programs too; as soon as you spot something you\ndon’t understand, ask yourself why not. If the meaning of a certain line\nis not obvious, ask what change would  it obvious? Don’t\nrely on comments; these are often wrong, out of date, or merely\nunhelpful.</p><p>In your own code, use comments sparingly, and as a last resort. Focus\non explaining  this code is here, not  it\ndoes—if that needs explanation, refactor the code to clarify it.</p><ul></ul><p>Don’t be afraid to refactor and re-work your programs ruthlessly\nuntil they’re as clear and simple and focused as you can possibly make\nthem. Check this by showing the code to someone else and asking them to\ntalk you through it, line by line. Watching where they stumble will show\nyou the speed-bumps in your code: keep refactoring until you’ve\nflattened them out.</p><p>Use “always valid values” in your programs, and design types so that\nusers can’t accidentally create values that won’t work. <a href=\"https://go-proverbs.github.io/\">Make the zero value useful</a>;\nthis lets users create literals of your type with minimal paperwork. For\nexample,  fields will default to , so\nmake that make sense for your type.</p><p>Don’t create useless “config” structs; use fields on the object\nitself to configure its behaviour. If these fields can be invalid, don’t\nlet users write them directly: instead, make them unexported, and\nprovide validating methods to get and set their values.</p><p>If your object has sensible defaults, write a constructor method that\nreturns a valid, default object ready to use. Add configuration using\n“WithX” methods:</p><pre><code></code></pre><p>Use named <a href=\"https://go.dev/blog/constants\">constants</a>\ninstead of magic values. <a href=\"https://pkg.go.dev/net/http#pkg-constants\"></a>\nis self-explanatory;  isn’t. Define your own constants\nso IDEs like GoLand can auto-complete them, preventing typos. Use <a href=\"https://bitfieldconsulting.com/posts/iota\"></a>\nto auto-assign arbitrary values:</p><pre><code></code></pre><pre><code></code></pre><p>Don’t require your program to run as  or in <a href=\"https://en.wikipedia.org/wiki/Setuid\"></a>\nmode; let users configure the minimal permissions and capabilities they\nneed.</p><h2>5. Wrap errors, don’t flatten</h2><pre><code></code></pre><p>Don’t inspect the string values of errors to find out what they are;\nthis is fragile. Instead, use <a href=\"https://pkg.go.dev/errors#Is\"></a>:</p><pre><code></code></pre><p>To add run-time information or context to an error, don’t flatten it\ninto a string. Use the  verb with \nto create a <a href=\"https://bitfieldconsulting.com/posts/wrapping-errors\"></a>\nerror:</p><pre><code></code></pre><p>This way,  can still match the wrapped error\nagainst your sentinel value, even though it contains extra\ninformation.</p><h2>6. Avoid mutable global state</h2><p>Even if your package doesn’t create goroutines, your users might\n it concurrently. Package-level variables can cause <a href=\"https://bitfieldconsulting.com/posts/racing-with-disaster\">data races</a>: reading a variable\nfrom one goroutine while writing it from another can crash your\nprogram.</p><p>Instead, use a  to prevent concurrent access,\nor allow access to the data only in a single “guard” goroutine that\ntakes read or write requests via a channel.</p><p>Instead, create a new instance with <a href=\"https://pkg.go.dev/net/http#NewServeMux\"></a>\n(for example) so that you own it exclusively, and then configure it how\nyou want.</p><h2>7. Use (structured)\nconcurrency sparingly</h2><p>Concurrent programming is a minefield: it’s easy to trigger crashes\nor race conditions. Don’t introduce concurrency to a program unless it’s\nunavoidable.</p><p>When you do use <a href=\"https://bitfieldconsulting.com/posts/goroutines\">goroutines</a>\nand channels, keep them strictly confined: once they escape the scope\nwhere they’re created, it’s hard to follow the flow of control. “Global”\ngoroutines, like global variables, can lead to hard-to-find bugs.</p><p>Make sure any goroutines you create will terminate before the\nenclosing function exits, using a <a href=\"https://go.dev/blog/context\">context</a> or <a href=\"https://pkg.go.dev/sync#WaitGroup\">waitgroup</a>:</p><pre><code></code></pre><p>The  call ensures that both tasks have completed\nbefore we move on, making control flow easy to understand, and\npreventing resource leaks.</p><p>Use <a href=\"https://pkg.go.dev/golang.org/x/sync/errgroup\">errgroups</a> to\ncatch the first error from a number of parallel tasks, and <a href=\"https://go.dev/play/p/2YOGE29kYsE\">terminate</a> all the\nothers:</p><pre><code></code></pre><p>When you take a <a href=\"https://go.dev/ref/spec#ChannelType\">channel</a> as the parameter\nto a function, take either its send or receive aspect, but not both.\nThis prevents a common kind of deadlock where the function tries to send\n receive on the same channel concurrently.</p><pre><code></code></pre><h2>8. Decouple code from\nenvironment</h2><p>We all know that good software avoids excessive \nbetween packages or components, but many programs are too tightly\ncoupled to the operating system or environment where they run.</p><p>Don’t depend on OS or environment-specific details. Don’t use <a href=\"https://pkg.go.dev/os#Getenv\"></a> or <a href=\"https://pkg.go.dev/os#Args\"></a> deep in your\npackage: only  should access environment variables or\ncommand-line arguments.</p><p>Instead of taking choices away from users of your package, let them\nconfigure it however they want. Be agnostic about how you’re configured.\nLet users decide whether they want to inject settings via the\nenvironment, flags, config files, API calls, or some other way.</p><p>Single binaries are easier for users to install, update, and manage;\ndon’t distribute config files. If necessary, create your config file at\nrun time using defaults.</p><p>Use <a href=\"https://pkg.go.dev/embed\"></a> to\nbundle static data, such as images or certificates, into your\nbinary:</p><pre><code></code></pre><p>Use <a href=\"https://pkg.go.dev/github.com/adrg/xdg\"></a>\ninstead of hard-coding paths. Don’t assume  exists.\nDon’t assume  disk storage exists, or is writable.</p><p>Go is popular in constrained environments, so be frugal with memory.\nDon’t read all your data at once; handle one chunk at a time, re-using\nthe same buffer. This will keep your memory footprint small and reduce\n<a href=\"https://go.dev/doc/gc-guide\">garbage collection</a> cycles.</p><p>Always check errors, and handle them if possible, retrying where\nappropriate. Report run-time errors to the user and exit gracefully,\nreserving  for <a href=\"https://www.alexedwards.net/blog/when-is-it-ok-to-panic-in-go\">internal\nprogram errors</a>. Don’t ignore errors using : this leads\nto obscure bugs. Assume that anything that can error \nerror, and handle it appropriately.</p><p>Retry on transient errors if that makes sense. Don’t let the program\npanic on predictable run-time errors, such as failing to read a file: a\nstack trace won’t help the user figure out what’s wrong. Reserve\n for unrecoverable internal program bugs only.</p><p>Don’t make the user rely on documentation to be able to run your\nprogram. Make their first-run experience a pleasant one: instead of\nnasty error messages, show usage hints and examples. Don’t try to\ninteract with users by prompting them via the console or dialog boxes.\nLet them automate your program and run it headlessly, using flags or\nconfig files to customise its behaviour.</p><p>If you use logging, don’t spam the user with pointless info messages:\nif nothing needs saying, say nothing. <a href=\"https://en.wikipedia.org/wiki/Logorrhea_(psychology)\">Logorrhea</a>\nis irritating, so don’t spam the user with trivia.</p><p>If you log at all, log only  errors that someone\nneeds to fix. Don’t use fancy loggers, just print to the console, and\nlet users redirect that output where they need it. Never log <a href=\"https://pkg.go.dev/log/slog#example-LogValuer-Secret\">secrets</a>\nor personal data.</p><p>Use <a href=\"https://pkg.go.dev/log/slog\"></a> to\ngenerate machine-readable JSON:</p><pre><code></code></pre><p>Logging is not for request-scoped troubleshooting: use <a href=\"https://opentelemetry.io/docs/concepts/signals/traces/\">tracing</a>\ninstead. Don’t log performance data or statistics: that’s what <a href=\"https://opentelemetry.io/docs/concepts/signals/metrics/\">metrics</a>\nare for.</p><p>Let’s be real: no program is perfect, and the same applies to\nprogrammers. We won’t always achieve all the goals set out here, or not\nat first. It’s more important to get the program working first, get it\nin front of users early, and only once it does what it’s supposed to\nshould we worry about making the code nicer.</p><p>My mountain-dwelling guru also says, “Make it work first, then make\nit right. Draft a quick <a href=\"https://wiki.c2.com/?WalkingSkeleton\">walking skeleton</a>, using\n<a href=\"https://bitfieldconsulting.com/posts/tdd-shameless-green\">shameless\ngreen</a>, and try it out on real users. Solve their problems first, and\nonly  focus on code quality.”</p><p>Equally, though, it’s a mistake not to  about code\nquality. You never know whether your Go package will be used in\nsomething like a <a href=\"https://hackaday.com/2015/10/26/killed-by-a-machine-the-therac-25/\">medical\nX-ray</a> machine or a <a href=\"https://www.simscale.com/blog/nasa-mars-climate-orbiter-metric/\">spacecraft</a>\ncontrol system. All software is critical to somebody.</p><p>Software takes more time to maintain than it does to write, so invest\nan extra 10% effort in refactoring, simplifying, and improving code\nwhile you still remember how it works.</p>","contentLength":11513,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust vs Go: ¿cuál elegir?","url":"https://bitfieldconsulting.com/posts/rust-vs-go-es","date":1771162200,"author":"John Arundel","guid":176,"unread":true,"content":"<p><strong>Rust y Go comparten mucho, pero sus diferencias importan. ¿Cuál deberías elegir?</strong></p><p> es un lenguaje <a href=\"https://bitfieldconsulting.com/posts/why-rust\">potente, rico y gratificante</a> que prioriza la\nseguridad y la corrección, sin sacrificar el poder ni la eficiencia. Es\nideal para crear software que no solo , sino que siga\nsiendo fiable con el tiempo.</p><p> es un lenguaje pequeño, fácil de aprender y\nrápido de escribir. Con Go, los desarrolladores pueden crear software\ncon rapidez y adaptarse con facilidad.</p><blockquote><p><em>Rust para alto riesgo, Go para bajo costo.</em></p></blockquote><p>Aquí está un resumen de ambos lenguajes que destaca sus ventajas,\nseñala lo que comparten y aclara sus diferencias clave.</p><p>Rust y Go son lenguajes relativamente modernos que se benefician de\nlas muchas lecciones que hemos aprendido a lo largo de las últimas\ndécadas de la ingeniería de software. Priorizan:</p><ul><li><p>. Rust y Go eliminan errores\ngraves de seguridad presentes en lenguajes como C y C++, incluidos los\n, los  y las .</p></li><li><p>. Ambos tienen cadenas de\nherramientas rápidas, potentes y unificadas; con ellos, los\ndesarrolladores pueden escribir, probar y implementar el software con\nfacilidad.</p></li><li><p><strong>Rendimiento y escalabilidad</strong>. Go y Rust se\ndirigen explícitamente a los proyectos de gran envergadura,\ndesarrollados por equipos grandes, que tienen que funcionar de forma\nfiable a gran escala y con alto rendimiento.</p></li></ul><p>Rust y Go tienen mucho en común, particularmente en comparación con\nlenguajes heredados como C/C++, Java, Python y Ruby. Pero tienen también\nfilosofías de diseño radicalmente diferentes.</p><p>Las prioridades clave de diseño de Go son:</p><ul><li><p>. Es un lenguaje pequeño, fácil de\naprender y rápido de escribir, particularmente en proyectos complejos.\nDeja fuera o simplifica muchas funciones avanzadas de otros\nlenguajes.</p></li><li><p>. Go proporciona servicios de alto\nnivel incluso de concurrencia y , para que el\ndesarrollador pueda enfocarse en resolver el problema en vez de estar\nahogado en papeleo.</p></li><li><p>. Go enfatiza fuertemente la\nretrocompatibilidad, lo que facilita el mantenimiento del software a\nlargo plazo. Rara vez introduce funciones nuevas; prefiere realizar\nmejoras pequeñas e incrementales en rendimiento y calidad de\nvida.</p></li></ul><p>Rust, por el contrario, se trata de:</p><ul><li><p>. Rust se orienta a aplicaciones\ncríticas para la seguridad—industriales, médicas o\naeroespaciales—mediante un análisis estático avanzado que elimina muchos\nerrores en tiempo de compilación.</p></li><li><p>. El compilador de Rust genera código\noptimizado que se ejecuta tan rápido como lo permite el hardware, con un\nrendimiento comparable al de C++ o incluso al lenguaje\nensamblador.</p></li><li><p>. Para obtener el máximo de las CPU\nmodernos, hay que programar a bajo nivel. Rust ofrece control estricto y\ninteroperabilidad excelente con bibliotecas de C/C++.</p></li></ul><p>Go es un lenguaje ideal cuando la situación exige:</p><ul><li><p>. Go tiene muy poca\nsintaxis, pocas palabras clave y solo las funciones esenciales. Los\ndesarrolladores pueden aprender los fundamentos y ser productivos\nrápidamente.</p></li><li><p><strong>Creación rápido de prototipos</strong>. Go se adapta a\ndesarrollo ágil porque los equipos pueden crear y evaluar rápidamente\nprototipos.</p></li><li><p><strong>Costes mínimos de desarrollo</strong>. Go es ideal para\nproyectos grandes y equipos porque es más fácil formar a los\ndesarrolladores, y requieran menos experiencia.</p></li></ul><h2>Los dominios ideales de Go</h2><p>Gracias a su enfoque en simplicidad y velocidad, Go es una elección\npopular para aplicaciones como las siguientes:</p><ul><li><p><strong>Servicios web, redes y nube</strong>. Go está orientado a\nmicroservicios pequeños y ligeros, backends web y sistemas basados en\ncontenedores, diseñados para operar a gran escala.</p></li><li><p><strong>Software de línea de negocio</strong>. Herramientas y\nflujos de trabajo a medida, gestión de datos, aplicaciones CRM / ERP y\nautomatismos de negocio funcionan bien con el estilo de desarrollo\nrápido de Go.</p></li><li><p><strong>Infraestructura, SRE y monitoreo</strong>. Go es ideal\npara la ingeniería de plataformas y facilita la creación de software\nconfiable y escalable para monitoreo, automatización, despliegue y\ngestión de configuración</p></li></ul><p>Rust es una buena elección cuando sus prioridades son:</p><ul><li><p>. Las funciones de\nseguridad de Rust son ideales cuando el código debe funcionar\ncorrectamente siempre y seguir haciéndolo durante años o incluso\ndécadas.</p></li><li><p>. Para , sistemas en tiempo real, aplicaciones de baja latencia,\nvideojuegos y cargas de trabajo de procesamiento intensivo, Rust se\nejecuta con gran rapidez y aprovecha al máximo el hardware\nsubyacente.</p></li><li><p><strong>Uso eficiente de recursos</strong>. La frugalidad y\neficiencia de Rust se adaptan bien a hardware limitado o de bajo consumo\no bajo coste como dispositivos integrados, IoT, satélites, vehículos y\naeronaves autónomas y sistemas militares.</p></li></ul><h2>Los dominios ideales de Rust</h2><p>Los puntos fuertes de Rust—seguridad, corrección y fiabilidad—lo\nhacen la mejor opción para:</p><ul><li><p><strong>Automatización industrial y robótica</strong>. Rust es\nideal para sistemas en tiempo real y telemática, como el control de\nplantas industriales, máquinas herramienta y la gestión de dispositivos\nconcurrentes.</p></li><li><p><strong>Automotriz, aeroespacial y militar</strong>. Estos\nentornos exigentes aprovechan las funciones críticas de seguridad y el\ncontrol de bajo nivel del hardware que ofrece Rust.</p></li><li><p>. Las cualidades de rendimiento\ny seguridad de Rust son muy adecuadas para aplicaciones intensivas en\ndatos, como imagen médica y diagnóstico, herramientas quirúrgicas\nrobóticas, dispositivos conectados—incluidos marcapasos y monitores de\nsalud—y la automatización de laboratorios.</p></li></ul><p>Rust y Go son ambos elecciones excelentes para el desarrollo de\nsoftware de propósito general y ofrecen una combinación de funciones y\nrendimiento que los sitúa por encima de competidores tradicionales como\nJava, C/C++, Python, Ruby, JavaScript / TypeScript, C#, PHP, Scala y\nSwift.</p><p>Go prioriza la simplicidad, la escalabilidad y la , por lo que es la mejor opción para equipos y\naplicaciones que necesitan lanzar rápidamente y mantener los costes al\nmínimo.</p><p>Rust, por otro lado, está optimizado para el software <strong>crítico\npara la seguridad</strong> que exige el máximo rendimiento; es la\nelección lógica cuando la fiabilidad prima sobre otros factores.</p><p>Bitfield Consulting ofrece capacitación y recursos de aprendizaje\nefectivos y de gran calidad para Rust, Go y habilidades generales de\ndesarrollo de software:</p>","contentLength":6171,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust vs Go","url":"https://bitfieldconsulting.com/posts/rust-vs-go","date":1770800640,"author":"John Arundel","guid":175,"unread":true,"content":"<p><strong>Rust and Go have many similarities, but also important differences. Which is right for you?</strong></p><p> is a <a href=\"https://bitfieldconsulting.com/posts/why-rust\">powerful, rich,\nand rewarding</a> language that prioritises safety and correctness\nwithout sacrificing power or efficiency. It’s ideal for building\nsoftware that  to work and keep working.</p><p> is a small, elegant language that’s easy to learn\nand quick to write. Go lets developers move fast, while staying\nflexible.</p><blockquote><p><em>Rust for high stakes, Go for low costs.</em></p></blockquote><p>Here’s a quick overview of both languages, highlighting the important\nadvantages of each, pointing out what they have in common, and showing\nwhere they differ in important ways.</p><p>If you’re a developer wondering which language would be better for\nyou to learn, or a business considering which language to adopt from a\nstrategic point of view, read on.</p><p>Both Rust and Go are relatively modern languages, incorporating many\nof the lessons we’ve learned from decades of software engineering. They\nboth prioritise:</p><ul><li><p>. Rust and Go are both designed to\neliminate the kind of correctness and security bugs that plague older\nlanguages such as C and C++, including buffer overflows, null pointers,\nand data races.</p></li><li><p>. Both languages have fast,\npowerful, unified toolchains that make it easy for developers to build,\ntest, and deploy their software.</p></li><li><p>. Go and Rust both\nexplicitly target large projects, developed by large teams, that must\noperate reliably at global scale in high-throughput\napplications.</p></li></ul><p>While Rust and Go have much in common, especially when compared to\nlegacy languages such as C/C++, Java, Python, and Ruby, they also have\nradically different design philosophies.</p><p>The key design priorities for Go are:</p><ul><li><p>. It’s a small language, intended to\nbe easy to learn and quick to compile, especially in large and complex\nprojects. It leaves out or simplifies many advanced features found in\nother languages.</p></li><li><p>. Go provides high-level facilities\nsuch as concurrency and garbage collection, letting the programmer focus\non solving their problem instead of getting bogged down with\nadmin.</p></li><li><p>. Go has a strong emphasis on backwards\ncompatibility, making software easier to maintain over the long term. It\nrarely introduces new features, preferring small, incremental\nperformance and quality-of-life improvements.</p></li></ul><p>Rust, on the other hand, is all about:</p><ul><li><p>. Rust targets safety-critical\napplications such as industrial, medical, and aerospace, using\nstate-of-the-art static analysis that eliminates many common bugs at\ncompile time.</p></li><li><p>. Rust’s clever compiler produces\noptimised code that runs as fast as the underlying hardware will allow,\nequalling the performance of C++ or assembly language programs without\nsacrificing memory safety.</p></li><li><p>. To get the most out of modern CPUs,\nprogrammers need to get “close to the metal”, and Rust offers low-level\ncontrol and excellent interoperability with C/C++ libraries.</p></li></ul><p>Go is an ideal language when the situation demands:</p><ul><li><p>. Go has very little syntax, few\nkeywords, and the bare minimum of features. Programmers can learn the\nfundamentals and be productive in the language very quickly.</p></li><li><p>. Agile development suits Go,\nbecause teams can get a skeleton product up and running quickly for\nevaluation.</p></li><li><p><strong>Minimal development costs</strong>. Because programmers\nare easier to train, and need less experience to be effective, Go works\nwell with bigger projects and teams that need to control cost.</p></li></ul><p>Because of its focus on simplicity and speed, Go is a popular choice\nfor applications such as:</p><ul><li><p><strong>Web, cloud, or network services</strong>. Small,\nlightweight, high-scale microservices, web application backends, and\ncontainer-based systems all favour Go.</p></li><li><p>. Bespoke, site-specific\ntools and workflows, data management, CRM/ERP applications, and business\nautomations work well with Go’s rapid development style.</p></li><li><p><strong>Infrastructure, SRE, and monitoring</strong>. Go is an\nideal platform engineering language, making it easy to build reliable\nand scalable monitoring, automation, deployment, and configuration\nmanagement software.</p></li></ul><p>Picking Rust makes sense when the priorities are:</p><ul><li><p><strong>Reliability and resilience</strong>. The safety features\nof Rust are ideal when code has to work correctly every time and stay\nworking for years or even decades with minimal maintenance.</p></li><li><p>. For system kernels and\ndrivers, real-time systems, low-latency applications, gaming, and\ncompute-intensive workloads like AI, Rust code runs fast and takes\nmaximum advantage of the available hardware.</p></li><li><p><strong>Efficient use of resources</strong>. Rust’s frugality and\nefficiency suits small, low-power, or low-cost hardware targets such as\nembedded devices, IoT, satellites, autonomous vehicles and aircraft, and\nmilitary systems.</p></li></ul><p>Rust’s core strengths of safety, correctness, and reliability make it\na top choice for:</p><ul><li><p><strong>Industrial automation and robotics</strong>. Rust is\nideal for real-time systems and telematics, controlling complex\nindustrial plant or machine tools, and concurrent handling of many\ndevices at once.</p></li><li><p><strong>Automotive, aerospace, and military</strong>. These\nchallenging environments make the most of Rust’s safety-critical\nfeatures and low-level hardware control.</p></li><li><p>. Rust’s performance and\nsafety qualities suit data-intensive imaging and diagnostic\napplications, robotic surgical tools, connected devices such as\npacemakers and home health monitors, and lab automation.</p></li></ul><p>Both Rust and Go are excellent choices for general-purpose software\ndevelopment, and offer a combination of features and performance that\nlift them above traditional competitors such as Java, C/C++, Python,\nRuby, JavaScript / TypeScript, C#, PHP, Scala, and Swift.</p><p>Go prioritises simplicity, scale, and , so it’s the best option for teams and applications\nthat need to ship fast, yet keep costs to a minimum.</p><p>Rust, on the other hand, is optimised for\n software demanding maximum performance;\nit’s the logical choice when reliability trumps all other concerns.</p><p>Bitfield Consulting offers high-quality, effective training and\nlearning resources for Rust, Go, and general software development\nskills:</p>","contentLength":5917,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"What's so great about Rust?","url":"https://bitfieldconsulting.com/posts/why-rust","date":1769949960,"author":"John Arundel, Cady Galletta","guid":174,"unread":true,"content":"<p><em>This article is for anyone who’s heard about Rust, and is curious to know what makes it worth looking at. No hype, just clear, pragmatic arguments to help you make an informed choice.</em></p><figure><img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp\" data-image-dimensions=\"800x655\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=1000w\" width=\"800\" height=\"655\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/c5730fb9-e6a4-4717-8ba0-6dc3c2330937/worth-your-time.webp?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\"></figure><p><strong>What’s so great about Rust, then?</strong> It’s a fair\nquestion, and one that can be surprisingly difficult to answer—at least,\nwhen someone puts you on the spot. It’s a bit like suddenly being asked\n“Why do you love your wife?”. If you feel a little tongue-tied, it’s not\nbecause you can’t think of any good answers. Rather, so many reasons may\ncome to mind that you’re not sure what to say .</p><p>And when people ask me “Why Rust?” I know it’s not out of skepticism,\nbut from genuine curiosity. They haven’t yet heard a clear signal\nthrough all the noise. They’re really asking “What makes Rust special,\nand why should  care?”</p><p>I’ll try to answer that without tripping over my tongue, or sounding\nlike a shiny-eyed cult member. And when we’re done, if you’re not\ninterested in accepting Rust as your personal saviour, I want you to\nknow that I am okay with that. Go in peace, my friend. Be well.</p><h2>The core value proposition</h2><p>Rust is a truly excellent programming language. Perhaps the best we\nhave, by any reasonable definition: powerful, portable, and\nproductive.</p><p>It’s modern enough to incorporate the lessons we’ve learned from\neighty-odd years of software engineering. Yet it doesn’t spend too many\ninnovation tokens: Rust is founded on solid, well-proven principles that\nhave worked in other languages for decades.</p><p>Rust leans hard into helping us write correct programs, catching as\nmany problems as possible at compile time, and catching any that remain\nat run time.</p><p>Not  software is safety-critical, but when lives really\nare at stake—in medical, industrial, military, automotive, and aerospace\napplications—we need a language that puts reliability front and\ncentre.</p><p>Here’s what that looks like in practice:</p><ul><li><p>. Rust automatically eliminates\nmany of the correctness and security problems that plague other\nlanguages, such as .</p></li><li><p>. Rust prevents accidental corruption\nor mutation of data by making sure that only one program thread or task\nat a time can have write access to values, preventing  and other mutability issues.</p></li><li><p>. Rust guarantees that\nreferences to data will always be valid, with extensive compile-time\nchecking:  can’t exist in Rust, removing a common\nsource of bugs and crashes.</p></li></ul><p>If this doesn’t mean much to you yet, don’t worry. You don’t need to\nbe a computer science guru to get the benefit of Rust’s safety features.\nLong story short, Rust protects the programmer by <em>making invalid\nstates unrepresentable</em>.</p><p>Safety is great, but it’s nothing without control. Critical software\nsuch as OS kernels and drivers, or real-time and high-frequency systems,\nneed unfettered access to the underlying hardware.</p><p>This is where Rust really shines, providing:</p><ul><li><p><strong>Hardware-level access to memory and registers</strong>.\nRust supports you, but it doesn’t get in your way. When every byte and\nnanosecond counts, you have full control of the machine.</p></li><li><p><strong>Ability to target CPU and GPU-specific features</strong>.\nWith broad architecture support, conditional compilation, and inline\nassembly language, your Rust programs can get the most from modern\nhardware.</p></li><li><p><strong>Controlled bypass of safety checks</strong>. Rust lets\nyou temporarily disable the guardrails for only those sections of code\nwhere it’s necessary. A special keyword identifies these “manual\noverride” sections, reducing the attack surface for potential bugs and\nvulnerabilities.</p></li><li><p><strong>Fast, predictable performance</strong>. Rust compiles to\nnative machine code, giving you the speed and efficiency of C++ or\nhand-tuned assembler. Rust doesn’t need a garbage collector, so there’s\nno memory reclamation overhead and no stop-the-world pauses.</p></li><li><p><strong>Interoperability with C/C++</strong>. Rust programs can\ntalk directly to kernel or SDK code written in C, C++, or any other\nlanguage, using Rust’s excellent <em>Foreign Function Interface</em>\n(FFI) support. You can call C libraries from Rust, or mix and match C++\ncomponents with Rust packages.</p></li></ul><p>Overall, Rust sits neatly in the “best of both worlds” space between\n memory-safe languages like <a href=\"https://bitfieldconsulting.com/posts/rust-vs-go\">Go</a>, and high-performance,\n languages like C++.</p><h2>Happy, productive developers</h2><p>Okay, Rust sounds good on the technical side, but what’s it like to\nuse in practice? Well, Rust routinely tops polls of the world’s\n languages, so I think the answer must be “pretty\ngreat”. Here are a few reasons why:</p><ul><li><p>. The Rust compiler is not\nonly smart and efficient, it has amazing error messages: not just what’s\nwrong, but  it’s wrong, and what you need to do to fix\nit.</p></li><li><p>. The Cargo tool manages\nyour dependencies, runs your tests, builds your code, generates your\ndocumentation, and publishes your package to Rust’s open-source\nrepository.</p></li><li><p>. Clippy, the Rust linter, not\nonly warns you about problematic code, it even suggests safer, faster,\nor more idiomatic alternatives.</p></li><li><p><strong>Rich, expressive language</strong>. Rust gives\nprogrammers powerful, state-of-the-art tools for problem-solving:\niterators, threads, closures, pattern-matching, sum types, generics,\nasync, and traits.</p></li><li><p>. If your Rust program compiles, it\nprobably works. No more stressing about hidden bugs, or whether your\ncode will blow up in production.</p></li></ul><p>Rust adoption is growing rapidly across the entire tech industry,\nmaking Rust a logical pick for businesses today:</p><ul><li><p>. Rust is a smart and\nforward-looking choice: there are millions of Rust users and the\ncommunity is growing all the time. Rust is stable and mature today, and\nit’ll be around for decades to come; that makes it a reliable long-term\nbet for your technology stack.</p></li><li><p>. You don’t have to throw away\nyour existing codebases. Rust has great interoperability with C, C++,\nand Java-based languages, as well as Python, meaning that you can adopt\nRust gradually into your products, component by component, service by\nservice. Rust supports all modern architectures and operating systems,\nincluding WebAssembly for browser-based apps.</p></li></ul><p>For developers looking to build a secure, rewarding career, Rust’s\nadvantages make it a safe bet:</p><ul><li><p>. Even though demand is growing\nfast, there aren’t yet all that many experienced Rust engineers out\nthere. New jobs are opening up all the time; you’ll have less\ncompetition for those vacancies, a wider choice of employers, and better\ncompensation and job security wherever you decide to land.</p></li><li><p>. Rust is versatile and used\nacross all kinds of industry sectors and applications. You won’t find\nyourself siloed by your choice of language; instead, Rust keeps your\noptions open.</p></li></ul><p>Happy developers make for a happy community, and the Rust community\nhas a friendly and welcoming atmosphere. Newbies feel supported, and\nthere’s a creative diversity of opinions and backgrounds. Governance is\ndemocratic and by consent; Rust is owned by its users, and no big-tech\ncompany can take it over or slap a licence fee on it.</p><p>Rust programmers take documentation seriously: the language has great\nfacilities for writing detailed hypertext docs with live, interactive\nexamples, Rust itself has all the docs you’ll ever need, and most Rust\ncrates are incredibly well-documented. After all, Rustaceans know that\nit doesn’t matter how great your software is if no one can figure out\nhow to use it.</p><p>Rust is attracting developers from all kinds of different backgrounds\nand language communities, including complete beginners. Here’s what Rust\nlooks like from each of these perspectives:</p><ul><li><p><strong>For beginners, it’s a great first language</strong>. Not\nonly will Rust teach you most of the important software concepts that\napply to all languages, it’ll also help you build a safe, thoughtful,\nand disciplined approach to programming.</p></li><li><p><strong>For C/C++ programmers, Rust offers safety plus\ninteroperability</strong>. You get the high-level abstractions and\nlow-level control you’re used to, but without the paperwork. Rust takes\nover the burden of memory management and correctness checks, and\nprovides seamless integration with existing C/C++ libraries and\napps.</p></li><li><p><strong>For Python users, Rust brings amazing\nperformance</strong>. There’s no interpreter or VM overhead, so Rust\nprograms run at the native speed of the hardware. Give your Python\ncodebase a speed boost by using Rust to implement Python modules, or\nbuild on your existing investment by calling into Python libraries from\nyour Rust programs.</p></li><li><p><strong>For embedded developers, Rust provides low-level control\nwith zero dependencies</strong>. It’s no surprise, given its strong\nfocus on correctness, that Rust is now a key component of Linux,\nWindows, iOS, macOS, Android, and other operating systems. It’s also\nideal for constrained environments like microcontrollers and embedded\ndevices: Rust can produce bare-metal binaries needing no runtime, no\noperating system, and no SDK.</p></li></ul><h2>Learn once, use everywhere</h2><p>Good engineers are T-shaped, as the saying goes: they have a broad\nknowledge of different technologies, but they also have deep expertise\nwith at least one. So, which language should you spend your valuable\ntime on really mastering?</p><ul><li><p> enough to write every kind of\nsoftware</p></li><li><p> enough to have world-class tools and\nlibraries available</p></li><li><p> enough that your Rust skills will be\nvaluable for decades to come</p></li></ul><p>Yet it’s really not so radically different to the languages you\nalready know. Take your existing software design and problem-solving\nskills and bring them to Rust; you’ll find everything works just the way\nyou’d expect.</p><p>Ultimately, software engineering is not just a job, it’s a\n, where if you bring care and skill to what you do, you’ll\nget satisfaction and fulfilment in return.</p><p>For me, Rust is more than just a tool. Learning Rust is stimulating,\nwriting Rust is liberating, and teaching Rust is rewarding. I’ll let the\ntechnical arguments speak for themselves, but in the end perhaps the\nmost persuasive reason I can offer you for considering Rust is this:</p><ul><li>There must be something special about a language that so many people\nfall in love with. And maybe love doesn’t always need a reason.</li></ul>","contentLength":9978,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}