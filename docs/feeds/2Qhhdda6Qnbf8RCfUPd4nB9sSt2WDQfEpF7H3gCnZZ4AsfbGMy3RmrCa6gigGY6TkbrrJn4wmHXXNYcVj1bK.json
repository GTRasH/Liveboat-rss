{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Supercharge Rust functions with implicit arguments using CGP v0.7.0","url":"https://contextgeneric.dev/blog/v0.7.0-release/","date":1772370678,"author":"/u/soareschen","guid":358,"unread":true,"content":"<p><a href=\"https://crates.io/crates/cgp\" target=\"_blank\" rel=\"noopener noreferrer\"></a> has been released, bringing a major expansion to the CGP macro toolkit. The centerpiece of this release is a suite of new annotations — , , , , , and  — that let you write context-generic code in plain function syntax with dramatically less boilerplate than before.</p><p>If you are new here, Context-Generic Programming (CGP) is a modular programming paradigm for Rust that unlocks powerful design patterns for writing code that is generic over a context () type. CGP lets you define functions and implementations that work across many different context types without any manual boilerplate, all through Rust's own trait system and with zero runtime overhead.</p><div><div><p>Before diving into the specifics of this release, it is highly recommended that you read the new <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/\"><strong>Area Calculation Tutorials</strong></a>, which walk through the motivation for CGP and the v0.7.0 features in far greater depth than this post can cover.</p></div></div><h2>The problem: parameter threading and tight coupling<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#the-problem-parameter-threading-and-tight-coupling\" aria-label=\"Direct link to The problem: parameter threading and tight coupling\" title=\"Direct link to The problem: parameter threading and tight coupling\" translate=\"no\">​</a></h2><p>To understand why v0.7.0 matters, it helps to appreciate the two limitations in conventional Rust that motivated it.</p><p>The first is <strong>explicit parameter threading</strong>. When a plain Rust function needs to pass values to another function, every intermediate caller in the chain must accept those values as arguments and forward them explicitly — even if they do not use them directly. As call chains grow, function signatures accumulate parameters that exist purely to satisfy the requirements of their callees.</p><p>The second is <strong>tight coupling to a concrete context struct</strong>. Rust developers often address parameter threading by grouping values into a single struct and defining methods on it. This does clean up the call signatures, but it tightly couples an implementation to one specific type. When the struct grows or needs to be extended, everything referencing it is affected, and there is no clean way to have multiple independent contexts share the same method without duplicating code.</p><p>CGP's  macro and  arguments, introduced in v0.7.0, address both of these problems at once.</p><h2>Define CGP functions using the  macro<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#define-cgp-functions-using-the-cgp_fn-macro\" aria-label=\"Direct link to define-cgp-functions-using-the-cgp_fn-macro\" title=\"Direct link to define-cgp-functions-using-the-cgp_fn-macro\" translate=\"no\">​</a></h2><p>The centerpiece of v0.7.0 is the  macro, which lets us write context-generic code in plain function syntax. A function decorated with  accepts a  parameter that refers to a , and may mark any of its arguments with  to indicate that those values should be automatically extracted from the context rather than passed by the caller.</p><p>For example, here is how we define a context-generic function that computes the area of a rectangle:</p><p>Three annotations do the work here.  augments the plain function and turns it into a context-generic capability.  provides a reference to whatever context this function is called on. And  on both  and  tells CGP to fetch those values automatically from  instead of requiring the caller to supply them.</p><p>The function body itself is entirely conventional Rust — there are no new concepts to learn beyond the annotations.</p><p>To use this function on a concrete type, we define a minimal context and apply  to enable generic field access on it:</p><p>The  macro generates implementations that allow CGP to access the fields of  generically by field name. With that in place, we can call  as a method:</p><p>That's it. CGP propagates the fields to the function arguments automatically. You do not need to write any implementation for  beyond deriving .</p><h3>Importing other CGP functions with <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#importing-other-cgp-functions-with-uses\" aria-label=\"Direct link to importing-other-cgp-functions-with-uses\" title=\"Direct link to importing-other-cgp-functions-with-uses\" translate=\"no\">​</a></h3><p>One of the most valuable properties of context-generic functions is their ability to compose with each other. The  attribute allows a CGP function to import another CGP function as a dependency, so that it can call it on  without the caller needing to know anything about the imported function's own requirements.</p><p>For example, here is how we define , which calls  internally:</p><p>The  attribute imports the  trait — the CamelCase name that  derives from the function name . We only need to declare  as an implicit argument, since  and  are already consumed internally by .</p><p>With  defined, we can introduce a second context that adds a  field:</p><p>Like , only  is needed. Both contexts can now coexist independently:</p><p>Importantly,  is never modified. It continues to support  on its own, and  is available only on contexts that also carry a  field. Two independent contexts can share the same function definitions without either one knowing about the other.</p><h3>Re-exporting imported CGP functions with <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#re-exporting-imported-cgp-functions-with-extend\" aria-label=\"Direct link to re-exporting-imported-cgp-functions-with-extend\" title=\"Direct link to re-exporting-imported-cgp-functions-with-extend\" translate=\"no\">​</a></h3><p>The  attribute is analogous to Rust's  statement for importing module constructs. This means that the imported CGP functions are hidden behind the generated  bounds using .</p><p>The  attribute lets you import and  another CGP function, so that it is available to anyone who imports your function. This works similarly to Rust's  for re-exporting module constructs.</p><p>For example, we can rewrite  to use  instead of :</p><p>This means that any construct that imports  now also has access to . For example:</p><p>The <code>print_scaled_rectangle_area</code> function only needs to import , yet it can call both  and  on .</p><h2>Using  in <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#using-implicit-in-cgp_impl\" aria-label=\"Direct link to using-implicit-in-cgp_impl\" title=\"Direct link to using-implicit-in-cgp_impl\" translate=\"no\">​</a></h2><p>CGP v0.7.0 also brings support for using  arguments inside , which is used to write named provider implementations for CGP components. This is especially useful when implementing traits defined with .</p><p>For example, here is how we define an  component and a named provider for it using implicit arguments:</p><p>Prior to v0.7.0, achieving the same result required defining a separate getter trait with , adding it to the provider's  clause, and calling its getter methods explicitly:</p><p>With , that entire layer of boilerplate disappears. The  and  values are fetched directly from the context, and there is no need to manually maintain a getter trait, a  clause, or individual method calls. Behind the scenes,  in  is semantically equivalent to  and is equally zero cost.</p><p>CGP v0.7.0 also introduces the  attribute for ergonomic import of other providers inside higher-order provider implementations. This is particularly useful when building providers that delegate part of their computation to a pluggable inner provider.</p><p>For example, suppose we want a general  that wraps any inner  provider and applies a scale factor to its result. We can now write this as follows:</p><p>The  attribute declares that  must implement the  provider trait. Before this attribute was available, we had to write the same constraint manually in the  clause with an explicit  parameter:</p><p>The main ergonomic improvement is that  automatically inserts  as the first generic parameter to the provider trait, so you can treat provider traits the same way as consumer traits without needing to understand the underlying difference. The provider can then be composed into any context via :</p><p>This shows that CGP providers are just plain Rust types, and higher-order providers like <code>ScaledAreaCalculator&lt;RectangleAreaCalculator&gt;</code> are simply generic type instantiations. No new runtime concepts are involved.</p><h2>Abstract type import with <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#abstract-type-import-with-use_type\" aria-label=\"Direct link to abstract-type-import-with-use_type\" title=\"Direct link to abstract-type-import-with-use_type\" translate=\"no\">​</a></h2><p>CGP v0.7.0 also introduces the  attribute for ergonomic import of abstract associated types. This lets you write context-generic functions that work with abstract types — such as a  type that might be , , or any other numeric type — without needing to write  prefixes everywhere.</p><p>For example, here is how we define a version of  that is generic over any scalar type by importing the  associated type from a  trait:</p><p>Without , the same function would require  throughout, which is noisier. Under the hood, <code>#[use_type(HasScalarType::Scalar)]</code> desugars to  and rewrites all references to the bare  identifier back to :</p><p>We can now define context types that use different scalar types. For example, here is a rectangle that uses  instead of :</p><p>And  will work seamlessly with  values:</p><p>The  attribute is also supported in both  and , making it uniformly available across the entire CGP surface:</p><h2>\"Isn't this just Scala implicits?\"<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#isnt-this-just-scala-implicits\" aria-label=\"Direct link to &quot;Isn't this just Scala implicits?&quot;\" title=\"Direct link to &quot;Isn't this just Scala implicits?&quot;\" translate=\"no\">​</a></h2><p>The word \"implicit\" may raise a flag for developers familiar with Scala's implicit parameter system — a feature with a well-documented reputation for producing confusing errors, ambiguous resolution, and code that is hard to trace. It's a fair concern, and it deserves a direct answer: CGP's  attribute shares the same surface-level motivation as Scala implicits (reducing boilerplate at call sites), but the underlying mechanisms are categorically different in the ways that matter most.</p><p> In Scala, the compiler searches a broad, layered  that spans local variables, companion objects, and imports — meaning an implicit value can materialize from almost anywhere. In CGP,  always resolves to a field on , and nowhere else. There is no ambient environment, no companion object search, and no imports to reason about.</p><p> Scala's type-only resolution means two in-scope values of the same type create an ambiguity that requires explicit disambiguation. CGP resolves by :  looks for a field named specifically  of type . Because Rust structs cannot have two fields with the same name, CGP implicit arguments are unambiguous by construction.</p><p> Every  annotation expands mechanically into a  trait bound and a  call — ordinary Rust constructs that any developer can read and verify. There is no hidden resolution phase, no special compiler magic, and no \"implicit hell\" accumulation risk.</p><h2>New area calculation tutorials<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#new-area-calculation-tutorials\" aria-label=\"Direct link to New area calculation tutorials\" title=\"Direct link to New area calculation tutorials\" translate=\"no\">​</a></h2><p>To accompany this release, two new <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/\"><strong>area calculation tutorials</strong></a> have been published that build up the full CGP feature set from first principles.</p><p>The <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/context-generic-functions\"><strong>Context-Generic Functions</strong></a> tutorial starts from plain Rust and introduces , , and . It walks through the full desugaring of  into Rust traits and blanket implementations, explains the -based zero-cost field access model, and compares CGP's implicit arguments to Scala's implicit parameters for readers coming from other ecosystems.</p><p>The <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/static-dispatch\"></a> tutorial introduces a second shape — the circle — to motivate a unified  interface. It demonstrates Rust's coherence restrictions as a concrete problem, then resolves them using  and named providers defined with . Finally, it covers  for configurable static dispatch and  for composing higher-order providers.</p><p>Both tutorials are designed to be read sequentially and assume no prior knowledge of CGP beyond basic Rust familiarity.</p><p>CGP v0.7.0 ships with preliminary support for <a href=\"https://agentskills.io/home\" target=\"_blank\" rel=\"noopener noreferrer\">agent skills</a> for LLMs. The <a href=\"https://contextgeneric.dev/docs/ai-assisted-development/skills/\"></a> document is specifically written to teach LLMs about CGP in a compact way.</p><p>If you would like to try out CGP with the assistance of an LLM, we recommend including the CGP skill in your prompts so that you can ask it to clarify any CGP concept.</p><p>v0.7.0 includes several minor breaking changes. The vast majority of existing CGP code is unaffected; the sections below describe what to look for and how to migrate.</p><h3>Removal of <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#removal-of-cgp_context\" aria-label=\"Direct link to removal-of-cgp_context\" title=\"Direct link to removal-of-cgp_context\" translate=\"no\">​</a></h3><p>The  macro has been removed, following its deprecation in v0.6.0. It is now idiomatic to define context types directly without any additional CGP macro applied to them.</p><p>Affected code can follow the migration guide in the <a href=\"https://contextgeneric.dev/blog/v0-6-0-release\">v0.6.0 post</a> to use the context type for delegation directly, instead of through a  delegation table.</p><h3>Change of consumer trait blanket implementation<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#change-of-consumer-trait-blanket-implementation\" aria-label=\"Direct link to Change of consumer trait blanket implementation\" title=\"Direct link to Change of consumer trait blanket implementation\" translate=\"no\">​</a></h3><p>The blanket implementation of consumer traits generated by  has been simplified. For example, given:</p><p>The generated blanket implementation is now:</p><p>That is, a  type implements the consumer trait if it also implements the provider trait with itself as the context type.</p><p>Prior to this, the blanket implementation involved an additional table lookup similar to the provider trait:</p><p>Since the provider trait's blanket implementation already performs the  lookup, the consumer trait no longer needs to repeat it. This also introduces the nice property that a provider trait implementation can satisfy the consumer trait directly, which may be useful in niche cases where a context acts as its own provider.</p><div><div><p>A consequence of this change is that when both the consumer trait and provider trait are in scope, there may be ambiguity when calling static methods on the context. Because a context that implements a consumer trait through  is also its own provider, Rust cannot determine which trait implementation to use without an explicit  receiver. Calls through  are unaffected.</p></div></div><p>With the removal of , it is now idiomatic to always build the delegate lookup table directly on the context type. The  and <code>delegate_and_check_components!</code> macros have been updated accordingly.</p><h4>Implicit check trait name<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#implicit-check-trait-name\" aria-label=\"Direct link to Implicit check trait name\" title=\"Direct link to Implicit check trait name\" translate=\"no\">​</a></h4><p>The check trait name can now be omitted:</p><p>By default, the macros generate a check trait named . The name can be overridden with a  attribute:</p><p>The following old syntax is :</p><p>The reason for the change is that it is simpler to parse an optional attribute at the start of a macro invocation than an optional name before a  keyword. The  syntax is both easier to implement and more consistent with how other CGP macros accept optional configuration.</p><p>The <code>delegate_and_check_components!</code> macro now supports  for CGP components that carry generic parameters. For example, given:</p><p>You can now both delegate and check a specific instantiation in one block:</p><p>To skip checking a particular component, use :</p><p>This is useful when you prefer to perform more complex checks using a dedicated  block.</p><h3>Use  instead of  for owned getter field values<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#use-copy-instead-of-clone-for-owned-getter-field-values\" aria-label=\"Direct link to use-copy-instead-of-clone-for-owned-getter-field-values\" title=\"Direct link to use-copy-instead-of-clone-for-owned-getter-field-values\" translate=\"no\">​</a></h3><p>Rust programmers prefer explicit  calls when passing owned values to function parameters. To align with this principle,  now requires  instead of  when the returned getter values are owned. For example:</p><p>The abstract type  must now implement  for the getter trait to work. The same requirement applies to  arguments:</p><p>The  requirement prevents potential surprises when an expensive value is implicitly cloned into an owned implicit argument.</p><h3>Removal of  type alias from <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#removal-of-typeof-type-alias-from-cgp_type\" aria-label=\"Direct link to removal-of-typeof-type-alias-from-cgp_type\" title=\"Direct link to removal-of-typeof-type-alias-from-cgp_type\" translate=\"no\">​</a></h3><p>The  macro no longer generates a type alias in the  form. For example, given:</p><p>The macro would previously generate:</p><p>This alias was originally provided to assist with abstract types in nested contexts. The new  attribute offers significantly better ergonomics for those same use cases, so the aliases are no longer expected to be used.</p><h3>Rename  to <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#rename-providetype-to-typeprovider\" aria-label=\"Direct link to rename-providetype-to-typeprovider\" title=\"Direct link to rename-providetype-to-typeprovider\" translate=\"no\">​</a></h3><p>The  CGP trait is used internally by  to generate helper type providers. Its provider trait was previously named  with a component named :</p><p>v0.7.0 renames the provider to  and the component to :</p><p>This brings the naming in line with the convention established by . For example, given:</p><p>The generated provider name is  and the component name is <code>ScalarTypeProviderComponent</code>.</p><h2>Getting started with v0.7.0<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#getting-started-with-v070\" aria-label=\"Direct link to Getting started with v0.7.0\" title=\"Direct link to Getting started with v0.7.0\" translate=\"no\">​</a></h2><p>CGP v0.7.0 represents the most significant ergonomics improvement to the library since its initial release. The combination of , , , and  removes the most common sources of boilerplate in CGP code — getter traits, manual  clauses, and  prefixes — while keeping the generated code fully transparent and zero cost.</p><p>If you are new to CGP, the <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/\"><strong>Area Calculation Tutorials</strong></a> are the best place to start. They build up the full picture from plain Rust functions all the way to composable, context-generic providers with pluggable static dispatch.</p>","contentLength":14781,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1rhwxnd/supercharge_rust_functions_with_implicit/"},{"title":"How much did Rust help you in your work?","url":"https://www.reddit.com/r/rust/comments/1rhts1u/how_much_did_rust_help_you_in_your_work/","date":1772360053,"author":"/u/therealsyumjoba","guid":357,"unread":true,"content":"<p>After years of obsessed learning for Rust along with its practices and semantics, it is really helping in my career, so much so that I would not shy away from admitting that Rust has been the prime factory in making me a hireable profile. </p><p>I basically have to thank Rust for making me able to write code that can go in production and not break even under unconventional circumstances.</p><p>I was wondering how much is Rust helping with careers and whatnot over here.</p><p>I wanna clarify, I did not simply \"land a Rust job\", I adopted Rust in my habits and it made me capable to subscribe to good contracts and deliver.</p>","contentLength":606,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Building a performant editor for Zaku with GPUI","url":"https://www.reddit.com/r/rust/comments/1rhdp64/building_a_performant_editor_for_zaku_with_gpui/","date":1772311971,"author":"/u/errmayank","guid":356,"unread":true,"content":"<p>First of all, this wouldn't be possible or would probably take months if not years (assuming i won't give up before) without Zed's source code, so thanks to all the talented folks at Zed, a lot of the things i did is inspired by how Zed does things for their own editor.</p><p>I built it on top of Zed's text crate which uses rope and sum tree underneath, there's a great read on their blog:</p><p>The linked YouTube video is also highly worth watching.</p><p>It doesn't have all the bells and whistles like LSP, syntax highlighting, folding, text wrap, inlay hints, gutter, etc. coz i don't need it for an API client at least for now, i'll add syntax highlighting &amp; gutter later though.</p><p>This is just a showcase post, maybe i'll make a separate post or write a blog on my experience in detail. Right now i'm stress testing it with large responses and so far it doesn't even break sweat at 1.5GB, it's able to go much higher but there's an initial freeze which is my main annoyance. also my laptop only has 16GB memory so there's that.</p><p>Postman, Insomnia and Bruno seemed to struggle at large responses and started stuttering, Postman gives up and puts a hard limit after 50MB, Insomnia went till 100MB, while Bruno crashed at 80MB</p>","contentLength":1206,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Is there any significant performance cost to using `array.get(idx).ok_or(Error::Whoops)` over `array[idx]`?","url":"https://www.reddit.com/r/rust/comments/1rhb97r/is_there_any_significant_performance_cost_to/","date":1772306151,"author":"/u/Perfect-Junket-165","guid":359,"unread":true,"content":"<p>And is `array.get(idx).ok_or(Error::Whoops)` faster than checking against known bounds explicitly with an `if` statement? </p><p>I'm doing a lot of indexing that doesn't lend itself nicely to an iterator. I suppose I could do a performance test, but I figured someone probably already knows the answer.</p>","contentLength":295,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I built a 1 GiB/s file encryption CLI using io_uring, O_DIRECT, and a lock-free triple buffer","url":"https://www.reddit.com/r/rust/comments/1rh9tj5/i_built_a_1_gibs_file_encryption_cli_using_io/","date":1772302816,"author":"/u/supergari","guid":360,"unread":true,"content":"<p>I got frustrated with how slow standard encryption tools (like GPG or age) get when you throw a massive 50GB database backup or disk image at them. They are incredibly secure, but their core ciphers are largely single-threaded, usually topping out around 200-400 MiB/s.</p><p>I wanted to see if I could saturate a Gen4 NVMe drive while encrypting, so I built .</p><p>I started out just mapping files into memory, but to hit multi-gigabyte/s throughput without locking up the CPU or thrashing the kernel page cache, the architecture evolved into something pretty crazy:</p><ul><li><strong>Lock-Free Triple-Buffering:</strong> Instead of using async MPSC channels (which introduced severe lock contention on small chunks), I built a 3-stage rotating state machine. While io_uring writes batch N-2 to disk, Rayon encrypts batch N-1 across all 12 CPU cores, and io_uring reads batch N.</li><li> I wrote a custom 4096-byte aligned memory allocator using std::alloc. This pads the header and chunk slots so the Linux kernel can bypass the page cache entirely and DMA straight to the drive.</li><li> It uses ring for assembly-optimized AES-256-GCM and ChaCha20-Poly1305. To prevent chunk-reordering attacks, it uses a TLS 1.3-style nonce derivation (base_nonce XOR chunk_index).</li><li> The full serialized file header (which contains the Argon2id parameters, salt, and base nonce) plus an is_final flag are bound into every single chunk's AAD. This mathematically prevents truncation and append attacks.</li></ul><p>It reliably pushes  entirely CPU-bound, and scales beautifully with cores.</p><p>The README has a massive deep-dive into the binary file format, the memory alignment math, and the threat model. I'd love for the community to tear into the architecture or the code and tell me what I missed.</p><p>Let me know what you think!</p>","contentLength":1737,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Servo v0.0.5 released","url":"https://github.com/servo/servo/releases/tag/v0.0.5","date":1772300688,"author":"/u/Right-Grapefruit-507","guid":361,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1rh8w41/servo_v005_released/"}],"tags":["dev"]}